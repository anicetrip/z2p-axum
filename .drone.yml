kind: pipeline
type: docker
name: z2p-axum-ci

platform:
  os: linux
  arch: amd64

# ======== 服务容器：MySQL（测试用） ========
services:
  - name: mysql
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: 1234
      MYSQL_DATABASE: newsletter
    command:
      - --default-authentication-plugin=mysql_native_password
      - --port=13306
    ports:
      - 13306

# ======== Cargo 缓存（需要仓库 Trusted） ========
volumes:
  - name: cargo-registry
    host:
      path: /var/lib/drone/cargo/registry
  - name: cargo-git
    host:
      path: /var/lib/drone/cargo/git
  - name: cargo-target
    host:
      path: /var/lib/drone/cargo/target

# ======== CI 步骤 ========
steps:
  - name: wait-for-mysql
    image: mysql:8.0
    commands:
      - |
        echo "Waiting for MySQL at mysql:13306 ..."
        for i in $(seq 1 120); do
          mysql -h mysql -uroot -p1234 -P 13306 -e "SELECT 1" && exit 0
          sleep 2
        done
        echo "MySQL not reachable on mysql:13306"
        exit 1

  - name: fmt
    image: rust:bookworm
    volumes:
      - name: cargo-registry
        path: /usr/local/cargo/registry
      - name: cargo-git
        path: /usr/local/cargo/git
      - name: cargo-target
        path: /drone/src/target
    commands:
      - rustup component add rustfmt
      - cargo fmt --all -- --check

  - name: test
    image: rust:bookworm
    environment:
      APP_DATABASE__HOST: mysql
      APP_DATABASE__PORT: "13306"
      APP_DATABASE__USERNAME: root
      APP_DATABASE__PASSWORD: 1234
      APP_DATABASE__DATABASE_NAME: newsletter
      APP_DATABASE__REQUIRE_SSL: "false"
    volumes:
      - name: cargo-registry
        path: /usr/local/cargo/registry
      - name: cargo-git
        path: /usr/local/cargo/git
      - name: cargo-target
        path: /drone/src/target
    commands:
      - cargo test --all --locked --workspace

  - name: coverage
    image: xd009642/tarpaulin:latest
    pull: if-not-exists
    privileged: true
    environment:
      APP_DATABASE__HOST: mysql
      APP_DATABASE__PORT: "13306"
      APP_DATABASE__USERNAME: root
      APP_DATABASE__PASSWORD: 1234
      APP_DATABASE__DATABASE_NAME: newsletter
      APP_DATABASE__REQUIRE_SSL: "false"
    volumes:
      - name: cargo-registry
        path: /usr/local/cargo/registry
      - name: cargo-git
        path: /usr/local/cargo/git
      - name: cargo-target
        path: /drone/src/target
    commands:
      - |
        cargo tarpaulin --out Html --out Lcov || {
          echo "tarpaulin failed"; exit 1;
        }
        test -f tarpaulin-report.html || { echo "report missing"; exit 1; }
        echo "Coverage HTML: ./tarpaulin-report.html"

  # ======== CI 内使用 Kaniko 构建镜像并导出为 tar（不推送） ========
  - name: build-image-tar
    image: gcr.io/kaniko-project/executor:debug
    environment:
      IMAGE_NAME: zero2prod
      TAR_NAME: zero2prod-${DRONE_COMMIT_SHA}.tar
    commands:
      - |
        /kaniko/executor \
          --context=dir:///drone/src \
          --dockerfile=/drone/src/Dockerfile \
          --destination=${IMAGE_NAME}:ci-${DRONE_COMMIT_SHA} \
          --no-push \
          --tarPath=/drone/src/${TAR_NAME}
        ls -lah /drone/src | grep "${TAR_NAME}" || { echo "image tar missing"; exit 1; }

  # ======== 把覆盖率报告拷到目标机 /tmp，避免 YAML 中的 ~ 解析问题 ========
  - name: scp-coverage-to-tmp
    image: appleboy/drone-scp
    when:
      branch: [ main ]
      event: [ push, tag ]
    settings:
      host: { from_secret: SSH_HOST }
      username: { from_secret: SSH_USER }
      password: { from_secret: SSH_PASSWORD }
      port: { from_secret: SSH_PORT }
      target: /tmp
      source:
        - tarpaulin-report.html
        - lcov.info
      overwrite: true
      command_timeout: 2m

  # ======== 把镜像 tar 拷到目标机 /tmp ========
  - name: scp-image-tar-to-tmp
    image: appleboy/drone-scp
    when:
      branch: [ main ]
      event: [ push, tag ]
    environment:
      TAR_NAME: zero2prod-${DRONE_COMMIT_SHA}.tar
    settings:
      host: { from_secret: SSH_HOST }
      username: { from_secret: SSH_USER }
      password: { from_secret: SSH_PASSWORD }
      port: { from_secret: SSH_PORT }
      target: /tmp
      source:
        - ${TAR_NAME}
      overwrite: true
      command_timeout: 3m

  # （可选）如仍需同步源码，可留存；不需要可删除
  - name: scp-code
    image: appleboy/drone-scp
    when:
      branch: [ main ]
      event: [ push, tag ]
    settings:
      host: { from_secret: SSH_HOST }
      username: { from_secret: SSH_USER }
      password: { from_secret: SSH_PASSWORD }
      port: { from_secret: SSH_PORT }
      target: /opt/zero2prod/src
      source:
        - .
      overwrite: true
      command_timeout: 2m

  # ======== CD：把 /tmp 文件移动到家目录，再本地 load & run；禁用 SSL（可切换） ========
  - name: deploy
    image: appleboy/drone-ssh
    when:
      branch: [ main ]
    event:
      - push
      - tag
    environment:
      PROD_DB_HOST: { from_secret: PROD_DB_HOST }
      PROD_DB_PORT: { from_secret: PROD_DB_PORT }
      PROD_DB_USER: { from_secret: PROD_DB_USER }
      PROD_DB_PASSWORD: { from_secret: PROD_DB_PASSWORD }
      PROD_DB_NAME: { from_secret: PROD_DB_NAME }
      # 可切换，默认 false：生产未开 TLS 也能跑
      PROD_DB_REQUIRE_SSL: "false"
    settings:
      host: { from_secret: SSH_HOST }
      username: { from_secret: SSH_USER }
      password: { from_secret: SSH_PASSWORD }
      port: { from_secret: SSH_PORT }
      command_timeout: 12m
      script:
        - set -euo pipefail
        - TAR_TMP=/tmp/zero2prod-${DRONE_COMMIT_SHA}.tar
        - COV_HTML_TMP=/tmp/tarpaulin-report.html
        - COV_LCOV_TMP=/tmp/lcov.info

        # 0) 把 /tmp 的工件移动到用户家目录（~）
        - [ -f "$COV_HTML_TMP" ] && mv -f "$COV_HTML_TMP" ~/
        - [ -f "$COV_LCOV_TMP" ]  && mv -f "$COV_LCOV_TMP"  ~/
        - [ -f "$TAR_TMP" ]       && mv -f "$TAR_TMP"       ~/

        # 1) 停/删旧容器
        - |
          if docker ps -a --format '{{.Names}}' | grep -q '^zero2prod$'; then
            docker stop zero2prod || true
            docker rm zero2prod || true
          fi

        # 2) 本地加载镜像 tar，并打上易用标签
        - TAR=~/zero2prod-${DRONE_COMMIT_SHA}.tar
        - test -f "${TAR}" || { echo "image tar not found: ${TAR}"; exit 1; }
        - docker load -i "${TAR}"
        - IMAGE_ID=$(docker images --format '{{.Repository}}:{{.Tag}} {{.ID}}' | awk '/zero2prod:ci-'"${DRONE_COMMIT_SHA}"'/{print $2}' | head -n1)
        - test -n "${IMAGE_ID:-}" || { echo "loaded image not found"; exit 1; }
        - docker tag "${IMAGE_ID}" zero2prod:latest
        - docker tag "${IMAGE_ID}" zero2prod:${DRONE_COMMIT_SHA}

        # 3) 运行新容器（默认不强制 SSL；如启用 TLS，把 PROD_DB_REQUIRE_SSL 改为 true 即可）
        - >
          docker run -d --name zero2prod
          --restart=always
          -p 8000:8000
          -e APP_ENVIRONMENT=production
          -e APP_DATABASE__HOST=${PROD_DB_HOST}
          -e APP_DATABASE__PORT=${PROD_DB_PORT}
          -e APP_DATABASE__USERNAME=${PROD_DB_USER}
          -e APP_DATABASE__PASSWORD=${PROD_DB_PASSWORD}
          -e APP_DATABASE__DATABASE_NAME=${PROD_DB_NAME}
          -e APP_DATABASE__REQUIRE_SSL=${PROD_DB_REQUIRE_SSL}
          zero2prod:latest

        # 4) 健康检查
        - |
          echo "Probing /health_check ..."
          for i in $(seq 1 60); do
            if curl -fsS http://127.0.0.1:8000/health_check >/dev/null; then
              echo "✅ health OK"; ok=1; break; fi; sleep 2; done
          if [ "${ok:-0}" != "1" ]; then
            echo "❌ health check failed"; docker logs zero2prod; exit 1; fi

        # 5) 清理非必要数据：镜像/容器垃圾 + 临时 tar
        - docker image prune -f || true
        - docker container prune -f || true
        - rm -f "${TAR}" || true